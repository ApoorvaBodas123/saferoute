import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'dart:math' as math;
import '../models/risk_zone.dart';
import '../models/user_profile.dart';
import '../services/risk_service.dart';
import '../services/route_service.dart';
import '../services/location_service.dart';
import '../services/ml_prediction_service.dart';
import '../services/route_analytics.dart';
import 'profile_screen.dart';

class MapScreen extends StatefulWidget {
  const MapScreen({super.key});

  @override
  State<MapScreen> createState() => _MapScreenState();
}

class _MapScreenState extends State<MapScreen> {
  @override
  void initState() {
    super.initState();
    loadUserLocation();
  }

  Future<void> loadUserLocation() async {
    final locationData = await LocationService.getCurrentLocation();

    // Add test route for debugging
    final testRoute = [
      LatLng(12.9716, 77.5946),
      LatLng(12.9762, 77.6033),
      LatLng(12.9850, 77.6100)
    ];
    
    setState(() {
      safestRoute = {
        points: testRoute,
        risk_score: 3.5,
        distance: 8.5,
        duration: 25,
      };
      
      riskyRoute = {
        points: testRoute,
        risk_score: 3.5,
        distance: 8.5,
        duration: 25,
      };
      
      allRoutes = [testRoute];
    });
    if (locationData != null) {
      setState(() {
        userLocation = LatLng(locationData.latitude!, locationData.longitude!);
      });
    }
  }

  bool showSafeOnly = false;
  LatLng? userLocation;
  LatLng? destination;
  List<List<LatLng>> allRoutes = [];
  Map<String, dynamic>? mlRouteResult;
  bool isMLRouteLoading = false;
  String selectedStrategy = 'balanced';

  // ü§ñ ML-powered route calculation
  Future<void> calculateMLRoute(LatLng start, LatLng end, String strategy) async {
    if (userLocation == null) return;

    setState(() {
      isMLRouteLoading = true;
      mlRouteResult = null;
    });

    try {
      final result = await MLPredictionService.getOptimizedRoute(
        start.latitude,
        start.longitude,
        end.latitude,
        end.longitude,
        strategy: strategy,
      );

      setState(() {
        mlRouteResult = result;
        isMLRouteLoading = false;
        
        // Convert ML result to displayable routes
        if (result != null && result[route_coordinates] != null) {
          final routePoints = (result[route_coordinates] as List).map((coord) => 
            LatLng(coord[0], coord[1])
          ).toList();
      } catch (e) {
        setState(() {
          isMLRouteLoading = false;
        });
        
        // Fallback to simple route
        final routePoints = [
          start,
          LatLng((start.latitude + end.latitude) / 2, (start.longitude + end.longitude) / 2),
          end
        ];
        
        setState(() {
          safestRoute = {
            points: routePoints,
            risk_score: 5.0,
            distance: 10.0,
            duration: 30,
          };
          
          riskyRoute = {
            points: routePoints,
            risk_score: 5.0,
            distance: 10.0,
            duration: 30,
          };
          
          allRoutes = [routePoints];
        });
            distance: result[total_distance] ?? 10.0,
            duration: result[estimated_duration] ?? 30,
          };
          
          riskyRoute = {
            points: routePoints,
            risk_score: result[total_risk_score] ?? 5.0,
            distance: result[total_distance] ?? 10.0,
            duration: result[estimated_duration] ?? 30,
          };
          
          allRoutes = [routePoints];
        }
      });
        
        // Convert ML result to displayable routes
        if (result != null && result[route_coordinates] != null) {
          allRoutes = [
            (result[route_coordinates] as List).map((coord) => 
              LatLng(coord[0], coord[1])
            ).toList()
          ];
        }
      });
      });
    } catch (e) {
      setState(() {
        isMLRouteLoading = false;
      });
      
      // Fallback to traditional routing
      final routes = await RouteService.getRoutes(start, end);
      setState(() {
        allRoutes = routes;
      });
    }
  }

  // üéØ Get dynamic risk score for a point
  // Utility method to calculate distance
  double _calculateDistance(double lat1, double lon1, double lat2, double lon2) {
    const double earthRadius = 6371; // in kilometers
    
    final double dLat = _toRadians(lat2 - lat1);
    final double dLon = _toRadians(lon2 - lon1);
    
    final double a = math.sin(dLat / 2) * math.sin(dLat / 2);
    final double b = math.cos(dLat / 2) * math.cos(dLat / 2);
    final double c = math.cos(dLat / 2) * math.sin(dLat / 2);
    final double d = math.sin(_toRadians(lat1)) * math.sin(_toRadians(lat2));
    final double e = math.cos(_toRadians(lat1)) * math.cos(_toRadians(lat2));
    
    final double h = (d - e).abs();
    final double i = (a - c).abs();
    final double angle = math.atan2(i, h);
    
    return earthRadius * 2 * angle;
  }

  static double _toRadians(double degrees) {
    return degrees * (math.pi / 180);
  }
  Future<Map<String, dynamic>> getDynamicRiskScore(LatLng point) async {
    try {
      return await MLPredictionService.getDynamicRiskScore(
        point.latitude,
        point.longitude,
      );
    } catch (e) {
      // Return fallback risk score
      final hour = DateTime.now().hour;
      final isNight = hour >= 22 || hour < 6;
      final isEvening = hour >= 18 && hour < 22;
      
      // Base risk calculation
      double baseRisk = 3.0;
      
      // Time-based adjustments
      double temporalMultiplier;
      if (isNight) {
        temporalMultiplier = 1.5;
      } else if (isEvening) {
        temporalMultiplier = 1.2;
      } else {
        temporalMultiplier = 1.0;
      }
      
      // Distance from center (simplified)
      final distanceFromCenter = _calculateDistance(point.latitude, point.longitude, 12.9716, 77.5946);
      double spatialMultiplier;
      if (distanceFromCenter < 5) {
        spatialMultiplier = 1.3;
      } else if (distanceFromCenter < 10) {
        spatialMultiplier = 1.1;
      } else {
        spatialMultiplier = 1.0;
      }
      
      final riskScore = baseRisk * temporalMultiplier * spatialMultiplier;
      final finalRiskScore = riskScore.clamp(0.0, 10.0);
      
      String riskLevel;
      if (finalRiskScore <= 3) {
        riskLevel = 'Low';
      } else if (finalRiskScore <= 6) {
        riskLevel = 'Medium';
      } else if (finalRiskScore <= 8) {
        riskLevel = 'High';
      } else {
        riskLevel = 'Very High';
      }
      
      return {
        'current_risk_score': finalRiskScore,
        'risk_probability': finalRiskScore / 10.0,
        'risk_level': riskLevel,
        'temporal_multiplier': temporalMultiplier,
        'is_fallback': true,
      };
    }
  }
  double calculateRouteRisk(List<LatLng> route, List<RiskZone> zones) {
    double riskSum = 0;

    for (final point in route) {
      for (final zone in zones) {
        final distance = const Distance().as(
          LengthUnit.Meter,
          point,
          LatLng(zone.lat, zone.lon),
        );

        if (distance < 800) {
          riskSum += zone.risk * (1 - distance / 800);
        }
      }
    }
    return riskSum;
  }

  // üé® Segment-wise coloring
  List<Polyline> buildSegmentColoredRoute(
    List<LatLng> route,
    List<RiskZone> zones,
  ) {
    List<Polyline> polylines = [];

    for (int i = 0; i < route.length - 1; i++) {
      LatLng current = route[i];
      LatLng next = route[i + 1];

      double maxNearbyRisk = 0;

      for (final zone in zones) {
        final distance = const Distance().as(
          LengthUnit.Meter,
          current,
          LatLng(zone.lat, zone.lon),
        );

        if (distance < 600) {
          if (zone.risk > maxNearbyRisk) {
            maxNearbyRisk = zone.risk;
          }
        }
      }

      Color color;

      if (maxNearbyRisk >= 5) {
        color = Colors.red; // High risk
      } else if (maxNearbyRisk >= 3) {
        color = Colors.orange; // Moderate
      } else {
        color = Colors.green; // Safe
      }

      polylines.add(
        Polyline(points: [current, next], strokeWidth: 6, color: color),
      );
    }

    return polylines;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Safe Route App (ML-Powered)'),
        backgroundColor: Colors.blueAccent,
        actions: [
          // Profile button
          IconButton(
            icon: const Icon(Icons.person),
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => const ProfileScreen(),
                ),
              );
            },
          ),
          // Strategy selector
          PopupMenuButton<String>(
            icon: const Icon(Icons.settings),
            onSelected: (String strategy) {
              setState(() {
                selectedStrategy = strategy;
              });
              // Recalculate route if destination exists
              if (destination != null && userLocation != null) {
                calculateMLRoute(userLocation!, destination!, strategy);
              }
            },
            itemBuilder: (BuildContext context) => [
              const PopupMenuItem<String>(
                value: 'safest',
                child: Text('üõ°Ô∏è Safest Route'),
              ),
              const PopupMenuItem<String>(
                value: 'fastest',
                child: Text('‚ö° Fastest Route'),
              ),
              const PopupMenuItem<String>(
                value: 'balanced',
                child: Text('‚öñÔ∏è Balanced Route'),
              ),
            ],
          ),
          IconButton(
            icon: const Icon(Icons.swap_horiz),
            onPressed: () {
              setState(() {
                showSafeOnly = !showSafeOnly;
              });
            },
          ),
        ],
      ),
      body: FutureBuilder<List<RiskZone>>(
        future: RiskService.loadZones(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }

          final zones = snapshot.data!;

          // Evaluate routes
          final evaluatedRoutes = allRoutes.map((route) {
            final risk = calculateRouteRisk(route, zones);
            return {'points': route, 'risk': risk};
          }).toList();

          Map<String, dynamic>? safestRoute;
          Map<String, dynamic>? riskyRoute;

          if (evaluatedRoutes.isNotEmpty) {
            evaluatedRoutes.sort(
              (a, b) => (a['risk'] as double).compareTo(b['risk'] as double),
            );

            safestRoute = evaluatedRoutes.first;
            riskyRoute = evaluatedRoutes.last;
          }

          return Column(
            children: [
              // üö® Banner
              if (safestRoute != null)
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(12),
                  color: Colors.green,
                  child: const Text(
                    'üü¢ Green = Safest Route   |   üî¥/üü° = Risky Areas',
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),

              Expanded(
                child: FlutterMap(
                  options: MapOptions(
                    center: userLocation ?? LatLng(12.9716, 77.5946),
                    zoom: 13,
                    onTap: (tapPosition, latlng) async {
                      if (userLocation == null) return;

                      // Set destination first
                      setState(() {
                        destination = latlng;
                      });

                      // Show feedback
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('üìç Destination set! Calculating optimal route...'),
                          backgroundColor: Colors.blueAccent,
                          duration: Duration(seconds: 2),
                        ),
                      );

                      // ü§ñ ML-powered route calculation
                      calculateMLRoute(userLocation!, latlng, selectedStrategy);
                    },
                  ),
                  children: [
                    TileLayer(
                      urlTemplate:
                          'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                      userAgentPackageName: 'com.example.safe_route_app',
                    ),

                    // ‚úÖ Draw ONLY safest route with segment coloring

                    // üõ£ Show both safe and risky routes
                    if (safestRoute != null && riskyRoute != null)
                      PolylineLayer(
                        polylines: [
                          // üü¢ Safe route first (thin)
                          Polyline(
                            points: safestRoute['points'] as List<LatLng>,
                            strokeWidth: 5,
                            color: Colors.green.withOpacity(0.7),
                          ),

                          // üî¥ Risk-colored route on top
                          ...buildSegmentColoredRoute(
                            riskyRoute['points'] as List<LatLng>,
                            zones,
                          ),
                        ],
                      ),

                    // üë§ User marker
                    MarkerLayer(
                      markers: [
                        Marker(
                          point: userLocation ?? LatLng(12.9716, 77.5946),
                          width: 40,
                          height: 40,
                          child: const Icon(
                            Icons.person_pin_circle,
                            color: Colors.blue,
                            size: 40,
                          ),
                        ),
                      ],
                    ),

                    // üéØ Destination marker
                    if (destination != null)
                      MarkerLayer(
                        markers: [
                          Marker(
                            point: destination!,
                            width: 40,
                            height: 40,
                            child: const Icon(
                              Icons.location_on,
                              color: Colors.red,
                              size: 40,
                            ),
                          ),
                        ],
                      ),

                    // üîÑ Loading indicator for ML route calculation
                    if (isMLRouteLoading)
                      const Center(
                        child: Card(
                          color: Colors.white,
                          child: Padding(
                            padding: EdgeInsets.all(16),
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                CircularProgressIndicator(),
                                SizedBox(height: 8),
                                Text('Calculating optimal route...'),
                              ],
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}
